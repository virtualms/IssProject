System waiter

// BROKER
mqttBroker "localhost": 1883 eventTopic "unibo/polar"

// DISPATCH REQUEST/REPLY AND EVENT
 
//Waiter
Event newClient : newClient(ID)
Event endCons: endCons(OK)
Event teaReady: orderReady(TEA, TABLE)
Event makeTea: makeTea(TEA, TABLE)

Dispatch newClientWait : newClientWait(TIME)
Dispatch atTable: atTable(OK)
Dispatch clientReady : clientReady(OK)
Dispatch paymentOK: paymentOK(OK)
Dispatch waiterReady: waiterReady(OK)
Dispatch callWaiter : callWaiter(OK)
Dispatch order: order(TEA)
Dispatch orderDelivered: orderDelivered(OK)
Dispatch dirtyTable: dirtyTable(OK)

Request moveToEntrance : moveToEntrance(ARG)
Request moveToTable1 : moveToTable1(ARG)
Request moveToTable2 : moveToTable2(ARG)
Request moveToBarman : moveToBarman(ARG)
Request moveToExit : moveToExit(ARG)
Request moveToHome : moveToHome(ARG)
Reply moveOk : moveOk(ARG)

//Walker
Request  movetoCell : movetoCell(X,Y)
Reply    atcell     : atcell(X,Y)
Reply	 walkbreak  : walkbreak(X,Y) 
 
//Waiterwalker
Dispatch cmd       : cmd(MOVE)

Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)
 
//BasicRobot
Event   obstacle   : obstacle( ARG ) 	//generated by distancefilter
Event  endall	   : endall( ARG )   
Event  sonar     	: sonar(DISTANCE,NAME)

Dispatch end       	: end(ARG) 

// CONTEXT
Context ctxwaiter ip [host="localhost" port=8090]
//Context ctxbarman ip [host="127.0.0.1" port=8060]
Context ctxsmartbell ip [host="127.0.0.1" port=8050]

//CODEDQACTOR
ExternalQActor client context ctxsmartbell
//ExternalQActor barman context ctxwaiter
ExternalQActor smartbell context ctxsmartbell

// Servono al BasicRobot
CodedQActor datacleaner    context ctxwaiter className "rx.dataCleaner"
CodedQActor distancefilter context ctxwaiter className "rx.distanceFilter"

//ACTOR

QActor waiter context ctxwaiter{
	// Variabili
	[#
		var ARG = "" 
		var WaitValue = 8000L
		var MaxTime = 15000L
		var dirtyTable = 0
		#]

	// Stato iniziale
	State s0 initial{
		println("---waiter | s0")
		
		discardMsg Off
	}
	Goto wait
	
	State wait{
		updateResource[# "waiting" #]
		println("---waiter | wait")		
		// aspetto per un messaggio
		
		// if c'è un cliente in attesa e c'è un tavolo libero e pulito
		//forward waiter -m clientReady: clientReady(id)
		
		if[# dirtyTable != 0 #] {
			forward waiter -m dirtyTable: dirtyTable(1)
		}
	}
	Transition t0 
				  whenTimeVar WaitValue -> goHome
			  
				  whenMsg dirtyTable -> clean
				  
  				  whenEvent newClient -> client
			      
			      whenMsg callWaiter -> getOrder
			      whenEvent teaReady -> serve  
			  
	State client{
		updateResource[# "newClient" #]
		println("---waiter | client")
		onMsg(newClient : newClient(ID)){
			
			[# 
				ARG = payloadArg(0)
			 #]
			
			println("---waiter | NUOVO CLIENTE CON ID: $ARG (ma questo id come lo uso??)")	
		// comunico con lo smart bell dicendogli se il cliente deve aspettare o se è ok
		// metto un cliente nella mia coda
		
		//if deve aspettare -> calcolo tempo massimo e glie lo do oppure gli dico tempo di attesa 0
		//emit newClientWait : newClientWait(time)

		//Assumendo che ci sia un solo cliente
		//emit newClientWait : newClientWait(0)
		forward smartbell -m newClientWait: newClientWait(0)
		}
	}
	//vado in enter perchè c'è solo un client
	Goto enter
	
	State enter{
		println("---waiter | enter")
		// vado alla porta e prendo il client e lo faccio accomodare a un tavolo
		request walker -m moveToEntrance : ENTRANCE
	}
	Transition t0
		whenReply moveOk -> atEntrance
		
	State atEntrance{
		println("---waiter | atEntrance")
		request walker -m moveToTable1 : TAVOLO1
	} Transition t0
		whenReply moveOk -> atTableFromEntrance
		
	State atTableFromEntrance{
		println("---waiter | atTableFromEntrance")
		delay 2000
		forward client -m atTable: atTable(ok)
	}
	Goto wait 
	
	State getOrder{
		updateResource[# "orderManagement" #]
		println("---waiter | getOrder")
		// vado al tavolo che vuole ordinare 
		request walker -m moveToTable1 : TAVOLO1
		
	}
	Transition t1 whenReply moveOk -> waitingOrder
	
	State waitingOrder{
		println("---waiter | waitingOrder")
		
		forward client -m waiterReady: waiterReady(OK)
	}
	Transition t1 
		whenMsg order -> sendOrder
	
	State sendOrder{
	// invio l'ordine al barman
	println("---waiter | sendOrder")
	onMsg(order: order(TEA)){
			
			[# 
				ARG = payloadArg(0)
			 #]
			 
			println("---waiter | invio l'ordine del $ARG al barista")
			emit makeTea: makeTea($ARG, 1)
			 }
	
	}
	Goto wait
	
	State serve{
		updateResource[# "serving" #]
		println("---waiter | serve")
		// vado dal barman per prendere l'ordine e lo porto al tavolo
		request walker -m moveToBarman : BARMAN
	}
	Transition t0 
			whenReply moveOk -> atBarman
			
	
	State atBarman{
		println("---waiter | atBarman")
		request walker -m moveToTable1 : TAVOLO1
	} Transition t0
		whenReply moveOk -> atTableFromBarman
		
	State atTableFromBarman{
		println("---waiter | ordine portato al tavolo")
		forward client -m orderDelivered: orderDelivered(OK)
	}Goto endOrder
	
	State endOrder {
	    println("---waiter | endOrder")
	} Transition t0 whenTimeVar MaxTime -> askToCollect
					//whenMsg endCons -> collect
					whenEvent endCons -> collect
		
	State askToCollect{
		println("---waiter | askToCollect")
		emit endCons : GOOUT		
	}
	Goto collect		
	
	State collect{
		updateResource[# "endClient" #]
		println("---waiter | collect")
		// vado al tavolo per prendere il pagamento dal client
		request walker -m moveToTable1 : TAVOLO1
		
		[#
			dirtyTable = dirtyTable + 1 
		#]
		
	}
	Transition t0 whenReply moveOk -> exit
	
	State exit{
		
		println("---waiter | exit")
		// accompagno il client all'uscita
		request walker -m moveToExit : EXIT
	}
	Transition t0 whenReply moveOk -> endExit
	
	State endExit{
		println("---waiter | endExit")
		// accompagno il client all'uscita
		forward client -m paymentOK: paymentOK
	}
	Goto wait
	
	State clean{
		updateResource[# "cleaning" #]
		println("---waiter | clean")
		request walker -m moveToTable1 : TAVOLO1
		delay 8000
		[#
			dirtyTable = dirtyTable - 1
		#]
			
	}
	Transition t0 whenReply moveOk -> wait
	
	State goHome{
		println("---waiter | goHome")
		request walker -m moveToHome : HOME
	}
	Goto wait
	//Transition t0 whenReply moveOk -> wait
}


QActor walker context ctxwaiter{
	
	[#
		var X_home		= "0"
		var Y_home		= "0"
		
		var X_barman		= "5"
		var Y_barman		= "0"

		var X_entrancedoor  = "0"
		var Y_entrancedoor  = "4"
	
		var X_exitdoor      = "5"
		var Y_exitdoor      = "4"
 
		var X_teatable1     = "2"
		var Y_teatable1     = "2"

		var X_teatable2     = "4"
		var Y_teatable2     = "2"	
	#]
	
	State s0 initial{
		println("---walker | s0")	
	} Goto wait
	
	State wait{
		println("---walker | wait")	
	}
	Transition t0
  				  whenRequest moveToEntrance -> moveToEntrance
  				  whenRequest moveToTable1 -> moveToTable1
  				  whenRequest moveToTable2 -> moveToTable2 
				  whenRequest moveToBarman -> moveToBarman 
				  whenRequest moveToExit -> moveToExit
				  whenRequest moveToHome -> moveToHome 
				  
	State moveToEntrance {
		println("---walker | moveToEntrace")	
		request waiterwalker -m movetoCell : movetoCell ($X_entrancedoor, $Y_entrancedoor)	
	} Transition t0 whenReply atcell -> respondEntrance
	
	State respondEntrance {
		println("---walker | respondEntrance")	
		replyTo moveToEntrance with moveOk : OK
	} Goto wait
		
	
	
	
	State moveToTable1 {
		println("---walker | moveToTable1")	
		request waiterwalker -m movetoCell : movetoCell ($X_teatable1, $Y_teatable1)	
	} Transition t0 whenReply atcell -> respondTeaTable1
	
	State respondTeaTable1 {
		println("---walker | respondTeaTable1")	
		replyTo moveToTable1 with moveOk : OK
	} Goto wait	
	
	
	
	
	State moveToTable2 {
		println("---walker | moveToTable2")	
		request waiterwalker -m movetoCell : movetoCell ($X_teatable2, $Y_teatable2)	
	} Transition t0 whenReply atcell -> respondTeaTable2
	
	State respondTeaTable2 {
		println("---walker | respondTeaTable2")	
		replyTo moveToTable2 with moveOk : OK
	} Goto wait	
	
	
	
	
	State moveToBarman {
		println("---walker | moveToBarman")	
		request waiterwalker -m movetoCell : movetoCell ($X_barman, $Y_barman)	
	} Transition t0 whenReply atcell -> respondBarman
	
	State respondBarman {
		println("---walker | respondBarman")	
		replyTo moveToBarman with moveOk : OK
	} Goto wait	
	
	
	
	
	State moveToExit{
		println("---walker | moveToExit")	
		request waiterwalker -m movetoCell : movetoCell ($X_exitdoor, $Y_exitdoor)	
	} Transition t0 whenReply atcell -> respondExit
	
	State respondExit {
		println("---walker | respondExit")	
		replyTo moveToExit with moveOk : OK
	} Goto wait
	
	
	
	
	State moveToHome{
		println("---walker | moveToHome")	
		request waiterwalker -m movetoCell : movetoCell ($X_home, $Y_home)	
	} Transition t0 whenReply atcell -> respondHome
	
	State respondHome{
		println("---walker | respondHome")	
		replyTo moveToHome with moveOk : OK
	} Goto wait
	
	
	
}




QActor waiterwalker context ctxwaiter{  
[#
	var XT = "0"
	var YT = "0" 
	var CurrentPlannedMove = ""
	var StepTime    	   = 340L
	val PauseTime          = 250L
	val BackTime           = 2 * StepTime / 3
	var obstacleFound      = false  
	
	val inmapname          		= "teaRoomExplored" 
#]

	State s0 initial {
		println("--waiterwalker | s0")	     
		
		run itunibo.planner.plannerUtil.initAI()
		solve( consult("tearoomkb.pl")	 )
  		
 		run itunibo.planner.plannerUtil.loadRoomMap( inmapname ) 		
 		run itunibo.planner.plannerUtil.showCurrentRobotState()	
 		
		delay 500
	}	
	Goto waitCmd   
	 
	State waitCmd {	     
 		println("--waiterwalker | waitCmd")
	}	
	Transition t0 whenRequest movetoCell -> walk
 	
	State walk{
		println("--waiterwalker | walk")
		onMsg( movetoCell : movetoCell(X,Y) ){
			[# XT = payloadArg(0)
			   YT = payloadArg(1)			  
			 #]
			run itunibo.planner.plannerUtil.planForGoal("$XT","$YT")
		}
	}
	Goto execPlannedMoves if[# itunibo.planner.plannerUtil.existActions() #] else noPlan

	State noPlan{
		println("--waiterwalker | noPlan")
		replyTo movetoCell with walkbreak : walkbreak( $XT,$YT )
	}
	Goto waitCmd
	
/*
 * Execute the plan
 */					  
 	State execPlannedMoves{ 
 		println("--waiterwalker | execPlannedMoves")
 		[#  CurrentPlannedMove = itunibo.planner.plannerUtil.getNextPlannedMove() #]
 		delayVar PauseTime
 	}
 	Goto wMove if [# CurrentPlannedMove == "w" #] else otherPlannedMove
 
 	State wMove {  
 		println("--waiterwalker | wMove")
		request basicrobot -m step : step( $StepTime  )
 	} 	
 	Transition t0   whenReply stepdone   -> stepDone   
					whenReply stepfail   -> stepFailed 
	 
 	State stepDone{
 		println("--waiterwalker | stepDone")  
 		run itunibo.planner.plannerUtil.updateMap(  "w" )
  	}
	Goto execPlannedMoves if [# CurrentPlannedMove.length > 0 #] else sendSuccessAnswer
		
	State stepFailed{  //has found an obstacle 
	    [# obstacleFound = true #]
 		println("--waiterwalker | stepFailed")
		onMsg(stepfail : stepfail(DURATION, CAUSE) ){
			[# val D = payloadArg(0).toLong()  ; val Dt = Math.abs(StepTime-D); val BackT = D/2 #] 
			if [# D > BackTime #] {    
				forward basicrobot -m cmd : cmd( s )
				delayVar BackT
				forward basicrobot -m cmd : cmd( h )
			}	 
 		}
	    run itunibo.planner.plannerUtil.updateMapObstacleOnCurrentDirection() 			    
 	}   
	Goto sendFailureAnswer
	
 	State otherPlannedMove{
 		println("--waiterwalker | otherPlannedMove")
  		if [# CurrentPlannedMove == "l" || CurrentPlannedMove == "r"  #]{
  			forward basicrobot -m cmd : cmd($CurrentPlannedMove)
 			run itunibo.planner.plannerUtil.updateMap( "$CurrentPlannedMove" )
  		} 
 	}   
 	Goto execPlannedMoves if [# CurrentPlannedMove.length > 0 #] else sendSuccessAnswer 
 
/*
 * Answers  
 */ 
 	State sendSuccessAnswer{
	     	println("--waiterwalker | sendSuccessAnswer")
	     	run itunibo.planner.plannerUtil.showCurrentRobotState()
	     	replyTo movetoCell with atcell : atcell($XT,$YT) 					
	}
	Goto waitCmd  

	State sendFailureAnswer{
	    println("--waiterwalker | sendFailureAnswer")
	    [# val Curx = itunibo.planner.plannerUtil.getPosX()
	       val Cury = itunibo.planner.plannerUtil.getPosY()	
	    #]
  		run itunibo.planner.plannerUtil.showCurrentRobotState()
	    replyTo movetoCell with walkbreak : walkbreak( $Curx, $Cury ) 					
	}
	Goto waitCmd
       
 }
 
 
 QActor basicrobot context ctxwaiter{
[#
  var StepTime      = 0L
  var StartTime     = 0L    
  var Duration      = 0L    
#]  
 	State s0 initial { 	 
 		println("--basicRobot | s0")
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")
 		[#  //For real robots
 			var robotsonar = context!!.hasActor("robotsonar")  
 			if( robotsonar != null ){  
 				//ACTIVATE THE DATA SOURCE robotsonar
 				forward("sonarstart", "sonarstart(1)" ,"robotsonar" ) 				
 				//SET THE PIPE
 				robotsonar.
 				subscribeLocalActor("datacleaner").
 				subscribeLocalActor("distancefilter").
 				subscribeLocalActor("basicrobot")		//in order to perceive obstacle
 			}
 		#]
 		updateResource [# "stopped" #]
 		discardMsg Off  //WE want receive any msg
 	}
	Goto work
	
	State work{ 
		 println("--basicRobot | work")
	} 
	Transition t1   whenMsg     cmd       -> execcmd
					whenRequest step      -> doStep
				  	whenMsg     end       -> endwork			  
	
	
	
	State execcmd{
 		println("--basicRobot | execcmd")
		onMsg( cmd : cmd(MOVE) ){
  			//activate the motors 
			run unibo.robot.robotSupport.move( payloadArg(0 ) )
			updateResource [# "movedone(${payloadArg(0)})" #]
		}
	 }
	 Goto work  

   	State doStep{ 
 		println("--basicRobot | doStep")  
		onMsg( step : step( T ) ){  
			[#	StepTime = payloadArg(0).toLong() 	#]  
			updateResource [# "step(${StepTime})" #]
			//println("basicrobot | doStep StepTime =$StepTime ")
 			run unibo.robot.robotSupport.move( "w" )
 			memoCurrentTime StartTime  
		}  
	}  
	Transition t0 
		whenTimeVar StepTime      -> stepPerhapsDone	
		whenEvent  obstacle       -> stepFail		 
  	
 	State stepPerhapsDone{ 
 		println("--basicRobot | stepPerhapsDone")
 		run unibo.robot.robotSupport.move( "h" )  //stop the robot
  	}
 	Transition t0 whenTimeVar StepTime    -> stepDone  //StepTime is the worst case
 				  whenEvent obstacle      -> stepFailDetected
	
	State stepDone{   
 		println("--basicRobot | stepDone")
 		run unibo.robot.robotSupport.move( "h" )  //stop the robot
		updateResource [# "stepDone($StepTime)" #]
   		replyTo step with stepdone : stepdone(ok)
  	}
	Goto work  
	
	State stepFailDetected{
 		println("--basicRobot | stepFailDetected")
		replyTo step with stepfail : stepfail($StepTime, obstacle)
    }
	Goto work 
	 
	State stepFail{  
 		println("--basicRobot | stepFail")
		setDuration Duration from StartTime
 		updateResource [# "stepFail($Duration)" #]
		emit obstacle : obstacle(unknown) 
 		replyTo step with stepfail : stepfail($Duration, obstacle)
    }
	Goto work 
	
	State endwork{ 
		println("--basicRobot | endwork")
		onMsg( end : end( V ) ){ 
			updateResource [# "move(end)" #]	 		
			run utils.virtualRobotSupportQak.terminatevr( )
		}
 		emit endall : endall(normal) 
 		terminate 1
	}  
	   
}

 
