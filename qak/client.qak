System client

//mqttBroker "localhost" : 1883 eventTopic "unibo/client"

//MESSAGES
//client-smartbell
Request clientInHall : clientInHall(msg)
Reply tempNo : tempNo(val)
Reply tempOk : tempOk(ID)

//waiter-client
Dispatch newClientOk : newClientOk(table)
Dispatch newClientWait : newClientWait(del)

Dispatch atTable : table(table)

Request order : order(te)
Reply orderGot : orderGot(te)
Dispatch orderDelivered : orderDelivered(te)

Dispatch teafinished : teafinished(arg)
Dispatch endCons : endCons(cons)

Dispatch paymentOk : paymentOk(bill)

/*
 * 
 * Dove inserire il messaggio atTable? E' relamente necessario?
 * 
 */


//CONTEXT
Context ctxclient ip [host="localhost" port=8020]

//ACTOR
QActor client context ctxclient{
	
		State s0 initial{
			println("client | s0")
			//init temp=random [36-37.5]
		}
		Goto checkTemp
		
		State checkTemp{
			//temperatura controllata tramite smartbell (messaggio a smartbell)
			//ok? ricevo id, altrimenti fuori dal sistema
			//request smartbell -m clientInHall(temp)
		}
		Transition t0 
			whenReply tempNo -> end
			whenReply tempOk -> waitingForWaiter
			
		State waitingForWaiter{
			//ricevo l'id
			//onmsg id=payload
			println("client | waiting for waiter")
			
			//request smartbell -m clientInHall(msg)
		}
		Transition t1
			whenMsg newClientOk -> waitingInHall
			whenMsg newClientWait -> waitingInHall
			
		
		State waitingInHall{
			//ricevo il delaymax, 
			//onmsg delayMax=payload
			println("client | waiting in hall")
		}
		Transition t2
			whenMsg atTable -> ordering
		
		State ordering{
			//faccio l'ordine? piu' te' da scegliere?
			//mando una request al waiter?
			
			//request (?) waiter -m order : order(te)
		}
		Transition t3 
			whenReply orderGot -> waitingInTable //oppure transizione quando ricevo ok dell'ordine?
		
		
		State waitingInTable{
			//aspetto finchÃ¨ non mi arriva il te'
			println("client | waitingInTable")
		}
		Transition t4 
			whenMsg orderDelivered -> consuming
		
		State consuming{
			//consumo il tÃ¨ e notifico con un evento che ho finito
			//oppure vengo esortato dal waiter ad andarmene se tempo>tmax
			
			println("client | consuming")
		}
		Transition t5 whenMsg endCons -> paying
		
		State paying{
			//pago e vengo accompagnato all'uscita dal waiter
		}
		Transition t6
			whenMsg paymentOk ->  end
		
		State end{
			terminate 0
		}
			
}
